Всем привет!
Сегодня мы с вами поговорим про такую вещь как Flamegraph
и про то как сильно он может облегчить вам жизнь.

(1. About author)
Прежде всего, пару слов о себе
Меня зовут Дима, я работаю в ЕПАМе последние полтора года, на проекте Fidor,
на данный момент в основном пишу на руби
__________________________________________

А то что вы сейчас видите на слайде собственно и есть Flamegraph

Давайте с вами пройдёмся по агенде

Сначала мы немного поговорим про профилирование, чтобы убедиться что мы с вами на on the same page,
Потом я покажу почему стоит использовать flamegraph
Затем мы с вами разберёмся как он работает
После этого для закрепления понимания мы с вами поиграем в небольшой квиз
Затем я покажу пару примеров из жизни,
И в заключение мы посмотрим где взять flamegraph под ваш язык программирования

..

Что ж, давайте начнём!
__________________________________________

Начнём с того что поговорим про профилирование
поднимите руки те кто знает что такое профилирование
так, хорошо..
а теперь те кто знает что такое сэмплинг (или сэмплирование)
хорошо, много рук..

Вообщем, профилирование - это сбор характеристик работы программы,
таких как время выполнения отдельных фрагментов, или объём оперативной памяти съедаемый ими..

Профилировать можно относительно разных метрик, например RAM или CPU,
нам с вами в контексте данного техтолка интересно именно профилирование относительно CPU,
т.е. определение того, какие части программы занимают больше всего процессорного времени
__________________________________________

Существует ещё такое понятие как Сэмплирование (или сэмплинг) - это вид профилирования,
при котором метрики собираются через равные, очень маленькие интервалы времени
Например, если сэмплируемый участок кода выполняется 5 секунд,
а сэмплы берутся каждую милисекунду, то вы получите 5000 сэмплов
__________________________________________

(2. So why Flamegraph?)
Так почему же я решил сегодня рассказать про Flamegraph ?

Дело в том, что за время моей работы на последних нескольких проектах мне не раз приходилось сталкиваться
с проблемами производительности, и когда я узнал про Flamegraph - он мне сильно помог.

__________________________________________

Представьте что определённый кусок кода в вашей системе работает медленно
Кусок достаточно большой, в нём достаточно много кода,
и ваша задача - ускорить время его выполнения

Один из вариантов разобраться - провести сэмплинг.

__________________________________________

Вы проводите сэмплинг.. ииии :
(картинка 1)
и вы сейчас скорей всего подумали "парень сошел с ума. зачем он показывает нам серый прямоугольник?"
Но на самом деле...
__________________________________________

Этот серый прямоугльник - пример сэмплинга какой-то программы, отображенного в текстовой форме  - тут 27 тысяч стэктрэйсов

Какой именно код подверли сэмплингу - не важно, это мог бы быть результат сэмплинга участка кода вашей программы

Можно ли в этом разобраться?
Естественно, нет

и что делать?
__________________________________________

Вот этот же результат сэмплинга в виде Flamegraph'а:
(картинка 2)

Сравните ещё раз:
Это
и вот это
Было
Стало

Флэймграф НАМНОГО удобней для восприятия,
мне на данный момент за две-три секунды становится понятно в какое место кода нужно смотреть
Главное - это понять принципы по которым он строится, и научиться его читать, о чём я сейчас и расскажу.

__________________________________________

Так всё же, что такое флэймграф?

- Флэймграф это инструмент для интерактивой визуализации стэктрэйсов
(да, да, именно интерактивной, потому что это не картинка -
сейчас я вам открою пример и покажу, что на самом деле это интерактивная SVGшка
по которой можно водить мышкой и получать какие-то данные)
- Оригинальная имплементация была написан Brendan Gregg,
Brendan Gregg - очень крутой чувак который собаку съел на производитльности,
на данный момент он "senior performance architect at Netflix".
Вообще я слышал что как минимум ребята из Нетфликса, Яндекса и Фэйсбука его юзают и очень довольны
- Довольны, потому что флэймграф позволяет быстро и точно находить участки кода,
отнимающие больше всего процессорного времени

__________________________________________

Но чтобы лучше понять как он работает, мы с вами немного погрузимся в историю его создания

https://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs(слайды 29-36)

Представьте что у вас есть набор стэктрэйсов, и вы хотите его каким-то образом визуализировать,
чтобы улучшить понимание работы программы и ускорить нахождение медленных мест

Brendan Gregg решил, а почему бы не не отображать стэктрэйсы как колонку раскрашенных произвольным цветом прямоугольников?
Посмотрите, вот слева один стэктрэйс работы программы,
этот стэктрэйс становится вот такой раскрашенной колонкой
читать эту колонку нужно снизу, т.е. key_cache_read -> mutex_lock -> mutex_lock_impl -> mutex_trylock_adaptive

__________________________________________

Затем, эти колонки можно поместить на один график, отсортировав по времени..
И ничего путного из этого не вышло, один стэктрэйс в итоге показан тут одной тонкой вертикальной линией
__________________________________________

Что бы тут могло хорошо помочь  - так это слияние, подумал Брендан

например, если у вас есть несколько рядом стоящих колонок с одинаковыми значениями соответствующих строк -
можно было бы эти значения склеить в один длинный прямоугольник, вот как на картинке. Туда бы и имя функции влезло..

И такое слияние само по себе иногда срабатывает...
Но чаще всего нет, давайте епреключимся на предыдущую картинку, чтобы убедиться что слияние мало поможет в данном случае.

И что же делать?
Смотрите
На данном графике стэктрэйсы по оси Х отсортированы по времени
Но ведь наша главная задача - не понять какой участок кода выполняется в какой момент времени,
наша главная задача - понять, какой участок кода - самый медленный,
и не важно, выполняется он в начале или в конце программы

Так что мы вполне можем поменять сортировку стэктрэйсов по оси Х, и это ООЧЕНЬ сильно поможет нам со слиянием
__________________________________________

И тут собственно и появляется флэймграф
__________________________________________

Флэймграф сортирует стэктрэйсы в алфавитном порядке
Сортировка применяется снизу к верху и помогает ЗНАЧИТЕЛЬНО улучшить слияние

Таким образом:

- Ось Y отображает глубину стэка, на самом верху - функция, которая непосредственно исполняется процессором,
под ней - её родители
 - Вся ширина флэймграфа - 100% времени выполнения программы
 - ширина одного прямоугольника пропорциональна времени выполнения данной функции или её наследников

(Quiz time!)
А теперь, я надеюсь что вам стало немного понятней,
но чтобы проверить и закрепить эти знания - мы с вами немного поиграем в вопрос-ответ
Я покажу вам несколько простейших флэймграфов, а вы постараетесь ответить на мои вопросы
Кто считает что знает ответ - поднимает руку, мы дадим вам микрофон
В конце техтолка мы наградим челвоека давшего больше всего правильных ответов (ТУТ НУЖНО ПОДУМАТЬ)

https://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs, слайды 38-48

(Time for real, interactive (?) examples!)
Хорошо, а теперь, после того как вы немного взбодрились и разобрались,
настало время посмотреть на то как это работает в жизни

Я приведу пару примеров из своего текущего проекта, но сначала мне придётся дать вам немного контекста
__________________________________________

Мой текущий проект - банковская система

Наши пользователи могут как создавать одиночные трансферы  (например вы пересылаете деньги другому человеку),

так и загружать так назвыаемые "батч" файлы, содержащие до 50 тысяч трансферов
(Например  это удобно если работодатель начисляет зарплату всем своим работникам)

Процесс отправки таких групповых трансферов происходит следующим образом:
1) пользователь загружает файл
2) система парсит его контент, создаёт сущности в базе, валидирует опредеённые поля
3) пользователь подписывает группу трансферов (батч) своей сигнатурой
4) батч улетает ни выполнение

-------------------------------------------
дальше сам
-------------------------------------------

Как видите, в каждом примере нам понадобилось всего несколько секунд,
чтобы разобраться, какой участок кода "тормозит", и исправить его


P.S.
Flamegraph для вашего ЯП (2-4 мин, с веселой историей или без, в зависимости от настроения публики)